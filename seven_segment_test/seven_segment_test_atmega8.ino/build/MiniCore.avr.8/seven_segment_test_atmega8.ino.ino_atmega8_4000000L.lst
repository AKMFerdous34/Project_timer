
/home/ferdous/.cache/arduino/sketches/3C8943CD6CB1DFB5F4177D67C3A4D766/seven_segment_test_atmega8.ino.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	40 c0       	rjmp	.+128    	; 0x82 <__ctors_end>
   2:	64 c0       	rjmp	.+200    	; 0xcc <__bad_interrupt>
   4:	63 c0       	rjmp	.+198    	; 0xcc <__bad_interrupt>
   6:	62 c0       	rjmp	.+196    	; 0xcc <__bad_interrupt>
   8:	61 c0       	rjmp	.+194    	; 0xcc <__bad_interrupt>
   a:	60 c0       	rjmp	.+192    	; 0xcc <__bad_interrupt>
   c:	5f c0       	rjmp	.+190    	; 0xcc <__bad_interrupt>
   e:	5e c0       	rjmp	.+188    	; 0xcc <__bad_interrupt>
  10:	5d c0       	rjmp	.+186    	; 0xcc <__bad_interrupt>
  12:	47 c1       	rjmp	.+654    	; 0x2a2 <__vector_9>
  14:	5b c0       	rjmp	.+182    	; 0xcc <__bad_interrupt>
  16:	5a c0       	rjmp	.+180    	; 0xcc <__bad_interrupt>
  18:	59 c0       	rjmp	.+178    	; 0xcc <__bad_interrupt>
  1a:	58 c0       	rjmp	.+176    	; 0xcc <__bad_interrupt>
  1c:	57 c0       	rjmp	.+174    	; 0xcc <__bad_interrupt>
  1e:	56 c0       	rjmp	.+172    	; 0xcc <__bad_interrupt>
  20:	55 c0       	rjmp	.+170    	; 0xcc <__bad_interrupt>
  22:	54 c0       	rjmp	.+168    	; 0xcc <__bad_interrupt>
  24:	53 c0       	rjmp	.+166    	; 0xcc <__bad_interrupt>

00000026 <__trampolines_end>:
	...
__trampolines_start():
  2e:	00 04       	cpc	r0, r0
  30:	05 07       	cpc	r16, r21
	...

0000003d <port_to_output_PGM>:
  3d:	00 00 00 00 38 00 35 00 32 00                       ....8.5.2.

00000047 <port_to_mode_PGM>:
  47:	00 00 00 00 37 00 34 00 31 00                       ....7.4.1.

00000051 <digital_pin_to_port_PGM>:
  51:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
  61:	03 03 03 03 02 02 03                                .......

00000068 <digital_pin_to_bit_mask_PGM>:
  68:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
  78:	04 08 10 20 40 80 40 00                             ... @.@.

00000080 <__ctors_start>:
__ctors_start():
  80:	b1 03       	fmuls	r19, r17

00000082 <__ctors_end>:
__dtors_end():
  82:	11 24       	eor	r1, r1
  84:	1f be       	out	0x3f, r1	; 63
  86:	cf e5       	ldi	r28, 0x5F	; 95
  88:	d4 e0       	ldi	r29, 0x04	; 4
  8a:	de bf       	out	0x3e, r29	; 62
  8c:	cd bf       	out	0x3d, r28	; 61

0000008e <__do_copy_data>:
__do_copy_data():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
  8e:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
  90:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
  92:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
  94:	ee e3       	ldi	r30, 0x3E	; 62
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
  96:	f8 e0       	ldi	r31, 0x08	; 8
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
  98:	02 c0       	rjmp	.+4      	; 0x9e <__do_copy_data+0x10>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
  9a:	05 90       	lpm	r0, Z+
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
  9c:	0d 92       	st	X+, r0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
  9e:	ae 3b       	cpi	r26, 0xBE	; 190
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
  a0:	b1 07       	cpc	r27, r17
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
  a2:	d9 f7       	brne	.-10     	; 0x9a <__do_copy_data+0xc>

000000a4 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  a4:	20 e0       	ldi	r18, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  a6:	ae eb       	ldi	r26, 0xBE	; 190
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  a8:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  aa:	01 c0       	rjmp	.+2      	; 0xae <.do_clear_bss_start>

000000ac <.do_clear_bss_loop>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  ac:	1d 92       	st	X+, r1

000000ae <.do_clear_bss_start>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  ae:	a2 3f       	cpi	r26, 0xF2	; 242
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  b0:	b2 07       	cpc	r27, r18
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  b2:	e1 f7       	brne	.-8      	; 0xac <.do_clear_bss_loop>

000000b4 <__do_global_ctors>:
__do_global_ctors():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  b4:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  b6:	c1 e4       	ldi	r28, 0x41	; 65
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  b8:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  ba:	03 c0       	rjmp	.+6      	; 0xc2 <__do_global_ctors+0xe>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  bc:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  be:	fe 01       	movw	r30, r28
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  c0:	b6 d3       	rcall	.+1900   	; 0x82e <__tablejump2__>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  c2:	c0 34       	cpi	r28, 0x40	; 64
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  c4:	d1 07       	cpc	r29, r17
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  c6:	d1 f7       	brne	.-12     	; 0xbc <__do_global_ctors+0x8>
  c8:	36 d1       	rcall	.+620    	; 0x336 <main>
  ca:	b7 c3       	rjmp	.+1902   	; 0x83a <_exit>

000000cc <__bad_interrupt>:
__vector_1():
  cc:	99 cf       	rjmp	.-206    	; 0x0 <__vectors>

000000ce <pinMode.constprop.9>:
pinMode():
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:31
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
  uint8_t bit = digitalPinToBitMask(pin);
  ce:	90 e0       	ldi	r25, 0x00	; 0
  d0:	fc 01       	movw	r30, r24
  d2:	e8 59       	subi	r30, 0x98	; 152
  d4:	ff 4f       	sbci	r31, 0xFF	; 255
  d6:	24 91       	lpm	r18, Z
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:32
  uint8_t port = digitalPinToPort(pin);
  d8:	8f 5a       	subi	r24, 0xAF	; 175
  da:	9f 4f       	sbci	r25, 0xFF	; 255
  dc:	fc 01       	movw	r30, r24
  de:	84 91       	lpm	r24, Z
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:35
  volatile uint8_t *reg, *out;

  if (port == NOT_A_PIN) return;
  e0:	88 23       	and	r24, r24
  e2:	99 f0       	breq	.+38     	; 0x10a <pinMode.constprop.9+0x3c>
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:38

  // JWS: can I let the optimizer do this?
  reg = portModeRegister(port);
  e4:	90 e0       	ldi	r25, 0x00	; 0
  e6:	88 0f       	add	r24, r24
  e8:	99 1f       	adc	r25, r25
  ea:	fc 01       	movw	r30, r24
  ec:	e9 5b       	subi	r30, 0xB9	; 185
  ee:	ff 4f       	sbci	r31, 0xFF	; 255
  f0:	a5 91       	lpm	r26, Z+
  f2:	b4 91       	lpm	r27, Z
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:39
  out = portOutputRegister(port);
  f4:	fc 01       	movw	r30, r24
  f6:	e3 5c       	subi	r30, 0xC3	; 195
  f8:	ff 4f       	sbci	r31, 0xFF	; 255
  fa:	85 91       	lpm	r24, Z+
  fc:	94 91       	lpm	r25, Z
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:54
    cli();
    *reg &= ~bit;
    *out |= bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
  fe:	8f b7       	in	r24, 0x3f	; 63
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:55
    cli();
 100:	f8 94       	cli
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:56
    *reg |= bit;
 102:	ec 91       	ld	r30, X
 104:	e2 2b       	or	r30, r18
 106:	ec 93       	st	X, r30
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:57
    SREG = oldSREG;
 108:	8f bf       	out	0x3f, r24	; 63
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:59
  }
}
 10a:	08 95       	ret

0000010c <digitalWrite>:
digitalWrite():
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:189
  }
}

void digitalWrite(uint8_t pin, uint8_t val)
{
  uint8_t timer = digitalPinToTimer(pin);
 10c:	90 e0       	ldi	r25, 0x00	; 0
 10e:	fc 01       	movw	r30, r24
 110:	ea 5d       	subi	r30, 0xDA	; 218
 112:	ff 4f       	sbci	r31, 0xFF	; 255
 114:	34 91       	lpm	r19, Z
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:190
  uint8_t bit = digitalPinToBitMask(pin);
 116:	fc 01       	movw	r30, r24
 118:	e8 59       	subi	r30, 0x98	; 152
 11a:	ff 4f       	sbci	r31, 0xFF	; 255
 11c:	24 91       	lpm	r18, Z
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:191
  uint8_t port = digitalPinToPort(pin);
 11e:	fc 01       	movw	r30, r24
 120:	ef 5a       	subi	r30, 0xAF	; 175
 122:	ff 4f       	sbci	r31, 0xFF	; 255
 124:	e4 91       	lpm	r30, Z
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:194
  volatile uint8_t *out;

  if (port == NOT_A_PIN) return;
 126:	ee 23       	and	r30, r30
 128:	e1 f0       	breq	.+56     	; 0x162 <digitalWrite+0x56>
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:198

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 12a:	33 23       	and	r19, r19
 12c:	49 f0       	breq	.+18     	; 0x140 <digitalWrite+0x34>
turnOffPWM():
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:77
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
  switch (timer)
 12e:	35 30       	cpi	r19, 0x05	; 5
 130:	c9 f0       	breq	.+50     	; 0x164 <digitalWrite+0x58>
 132:	37 30       	cpi	r19, 0x07	; 7
 134:	d1 f0       	breq	.+52     	; 0x16a <digitalWrite+0x5e>
 136:	34 30       	cpi	r19, 0x04	; 4
 138:	19 f4       	brne	.+6      	; 0x140 <digitalWrite+0x34>
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:82
  {
    // Timer1
    #if defined(TCCR1A) && defined(COM1A1)
      case TIMER1A:
        TCCR1A &= ~_BV(COM1A1);
 13a:	8f b5       	in	r24, 0x2f	; 47
 13c:	8f 77       	andi	r24, 0x7F	; 127
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:87
        break;
    #endif
    #if defined(TCCR1A) && defined(COM1B1)
      case TIMER1B:
        TCCR1A &= ~_BV(COM1B1);
 13e:	8f bd       	out	0x2f, r24	; 47
digitalWrite():
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:200

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);
 140:	f0 e0       	ldi	r31, 0x00	; 0
 142:	ee 0f       	add	r30, r30
 144:	ff 1f       	adc	r31, r31
 146:	e3 5c       	subi	r30, 0xC3	; 195
 148:	ff 4f       	sbci	r31, 0xFF	; 255
 14a:	a5 91       	lpm	r26, Z+
 14c:	b4 91       	lpm	r27, Z
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:202

  uint8_t oldSREG = SREG;
 14e:	8f b7       	in	r24, 0x3f	; 63
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:203
  cli();
 150:	f8 94       	cli
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:205

  if (val == LOW) {
 152:	61 11       	cpse	r22, r1
 154:	0e c0       	rjmp	.+28     	; 0x172 <digitalWrite+0x66>
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:206
    *out &= ~bit;
 156:	9c 91       	ld	r25, X
 158:	e2 2f       	mov	r30, r18
 15a:	e0 95       	com	r30
 15c:	e9 23       	and	r30, r25
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:208
  } else {
    *out |= bit;
 15e:	ec 93       	st	X, r30
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:211
  }

  SREG = oldSREG;
 160:	8f bf       	out	0x3f, r24	; 63
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:212
}
 162:	08 95       	ret
turnOffPWM():
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:87
        TCCR1A &= ~_BV(COM1A1);
        break;
    #endif
    #if defined(TCCR1A) && defined(COM1B1)
      case TIMER1B:
        TCCR1A &= ~_BV(COM1B1);
 164:	8f b5       	in	r24, 0x2f	; 47
 166:	8f 7d       	andi	r24, 0xDF	; 223
 168:	ea cf       	rjmp	.-44     	; 0x13e <digitalWrite+0x32>
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:99
    #endif
    
    // Timer2
    #if defined(TCCR2) && defined(COM21)
      case TIMER2:
        TCCR2 &= ~_BV(COM21);
 16a:	85 b5       	in	r24, 0x25	; 37
 16c:	8f 7d       	andi	r24, 0xDF	; 223
 16e:	85 bd       	out	0x25, r24	; 37
 170:	e7 cf       	rjmp	.-50     	; 0x140 <digitalWrite+0x34>
digitalWrite():
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring_digital.c:208
  cli();

  if (val == LOW) {
    *out &= ~bit;
  } else {
    *out |= bit;
 172:	ec 91       	ld	r30, X
 174:	e2 2b       	or	r30, r18
 176:	f3 cf       	rjmp	.-26     	; 0x15e <digitalWrite+0x52>

00000178 <SevSeg::digitOff(unsigned char) [clone .constprop.12]>:
digitOff():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:354
}

// digitOff
/******************************************************************************/
// Turns a digit off, as well as all segment pins
void SevSeg::digitOff(uint8_t digitNum) {
 178:	cf 93       	push	r28
 17a:	df 93       	push	r29
 17c:	c8 2f       	mov	r28, r24
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:355
  for (uint8_t segmentNum = 0 ; segmentNum < numSegments ; segmentNum++) {
 17e:	d0 e0       	ldi	r29, 0x00	; 0
 180:	80 91 df 00 	lds	r24, 0x00DF	; 0x8000df <sevseg+0x18>
 184:	d8 17       	cp	r29, r24
 186:	50 f4       	brcc	.+20     	; 0x19c <SevSeg::digitOff(unsigned char) [clone .constprop.12]+0x24>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:356
    digitalWrite(segmentPins[segmentNum], segmentOffVal);
 188:	ed 2f       	mov	r30, r29
 18a:	f0 e0       	ldi	r31, 0x00	; 0
 18c:	e9 53       	subi	r30, 0x39	; 57
 18e:	ff 4f       	sbci	r31, 0xFF	; 255
 190:	60 91 ca 00 	lds	r22, 0x00CA	; 0x8000ca <sevseg+0x3>
 194:	87 85       	ldd	r24, Z+15	; 0x0f
 196:	ba df       	rcall	.-140    	; 0x10c <digitalWrite>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:355

// digitOff
/******************************************************************************/
// Turns a digit off, as well as all segment pins
void SevSeg::digitOff(uint8_t digitNum) {
  for (uint8_t segmentNum = 0 ; segmentNum < numSegments ; segmentNum++) {
 198:	df 5f       	subi	r29, 0xFF	; 255
 19a:	f2 cf       	rjmp	.-28     	; 0x180 <SevSeg::digitOff(unsigned char) [clone .constprop.12]+0x8>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:358
    digitalWrite(segmentPins[segmentNum], segmentOffVal);
  }
  digitalWrite(digitPins[digitNum], digitOffVal);
 19c:	ec 2f       	mov	r30, r28
 19e:	f0 e0       	ldi	r31, 0x00	; 0
 1a0:	e9 53       	subi	r30, 0x39	; 57
 1a2:	ff 4f       	sbci	r31, 0xFF	; 255
 1a4:	60 91 c8 00 	lds	r22, 0x00C8	; 0x8000c8 <sevseg+0x1>
 1a8:	87 81       	ldd	r24, Z+7	; 0x07
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:359
}
 1aa:	df 91       	pop	r29
 1ac:	cf 91       	pop	r28
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:358
// Turns a digit off, as well as all segment pins
void SevSeg::digitOff(uint8_t digitNum) {
  for (uint8_t segmentNum = 0 ; segmentNum < numSegments ; segmentNum++) {
    digitalWrite(segmentPins[segmentNum], segmentOffVal);
  }
  digitalWrite(digitPins[digitNum], digitOffVal);
 1ae:	ae cf       	rjmp	.-164    	; 0x10c <digitalWrite>

000001b0 <SevSeg::segmentOff(unsigned char) [clone .constprop.11]>:
segmentOff():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:331
}

// segmentOff
/******************************************************************************/
// Turns a segment off, as well as all digit pins
void SevSeg::segmentOff(uint8_t segmentNum) {
 1b0:	cf 93       	push	r28
 1b2:	df 93       	push	r29
 1b4:	c8 2f       	mov	r28, r24
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:332
  for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
 1b6:	d0 e0       	ldi	r29, 0x00	; 0
 1b8:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <sevseg+0x17>
 1bc:	d8 17       	cp	r29, r24
 1be:	50 f4       	brcc	.+20     	; 0x1d4 <SevSeg::segmentOff(unsigned char) [clone .constprop.11]+0x24>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:333
    digitalWrite(digitPins[digitNum], digitOffVal);
 1c0:	ed 2f       	mov	r30, r29
 1c2:	f0 e0       	ldi	r31, 0x00	; 0
 1c4:	e9 53       	subi	r30, 0x39	; 57
 1c6:	ff 4f       	sbci	r31, 0xFF	; 255
 1c8:	60 91 c8 00 	lds	r22, 0x00C8	; 0x8000c8 <sevseg+0x1>
 1cc:	87 81       	ldd	r24, Z+7	; 0x07
 1ce:	9e df       	rcall	.-196    	; 0x10c <digitalWrite>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:332

// segmentOff
/******************************************************************************/
// Turns a segment off, as well as all digit pins
void SevSeg::segmentOff(uint8_t segmentNum) {
  for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
 1d0:	df 5f       	subi	r29, 0xFF	; 255
 1d2:	f2 cf       	rjmp	.-28     	; 0x1b8 <SevSeg::segmentOff(unsigned char) [clone .constprop.11]+0x8>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:335
    digitalWrite(digitPins[digitNum], digitOffVal);
  }
  digitalWrite(segmentPins[segmentNum], segmentOffVal);
 1d4:	ec 2f       	mov	r30, r28
 1d6:	f0 e0       	ldi	r31, 0x00	; 0
 1d8:	e9 53       	subi	r30, 0x39	; 57
 1da:	ff 4f       	sbci	r31, 0xFF	; 255
 1dc:	60 91 ca 00 	lds	r22, 0x00CA	; 0x8000ca <sevseg+0x3>
 1e0:	87 85       	ldd	r24, Z+15	; 0x0f
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:336
}
 1e2:	df 91       	pop	r29
 1e4:	cf 91       	pop	r28
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:335
// Turns a segment off, as well as all digit pins
void SevSeg::segmentOff(uint8_t segmentNum) {
  for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
    digitalWrite(digitPins[digitNum], digitOffVal);
  }
  digitalWrite(segmentPins[segmentNum], segmentOffVal);
 1e6:	92 cf       	rjmp	.-220    	; 0x10c <digitalWrite>

000001e8 <SevSeg::digitOn(unsigned char) [clone .constprop.7]>:
digitOn():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:342

// digitOn
/******************************************************************************/
// Turns a digit on, as well as all corresponding segment pins
// (according to digitCodes[])
void SevSeg::digitOn(uint8_t digitNum) {
 1e8:	1f 93       	push	r17
 1ea:	cf 93       	push	r28
 1ec:	df 93       	push	r29
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:343
  digitalWrite(digitPins[digitNum], digitOnVal);
 1ee:	c8 2f       	mov	r28, r24
 1f0:	d0 e0       	ldi	r29, 0x00	; 0
 1f2:	c9 53       	subi	r28, 0x39	; 57
 1f4:	df 4f       	sbci	r29, 0xFF	; 255
 1f6:	60 91 c7 00 	lds	r22, 0x00C7	; 0x8000c7 <sevseg>
 1fa:	8f 81       	ldd	r24, Y+7	; 0x07
 1fc:	87 df       	rcall	.-242    	; 0x10c <digitalWrite>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:344
  for (uint8_t segmentNum = 0 ; segmentNum < numSegments ; segmentNum++) {
 1fe:	10 e0       	ldi	r17, 0x00	; 0
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:345
    if (digitCodes[digitNum] & (1 << segmentNum)) { // Check a single bit
 200:	6a 96       	adiw	r28, 0x1a	; 26
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:344
/******************************************************************************/
// Turns a digit on, as well as all corresponding segment pins
// (according to digitCodes[])
void SevSeg::digitOn(uint8_t digitNum) {
  digitalWrite(digitPins[digitNum], digitOnVal);
  for (uint8_t segmentNum = 0 ; segmentNum < numSegments ; segmentNum++) {
 202:	80 91 df 00 	lds	r24, 0x00DF	; 0x8000df <sevseg+0x18>
 206:	18 17       	cp	r17, r24
 208:	a0 f4       	brcc	.+40     	; 0x232 <SevSeg::digitOn(unsigned char) [clone .constprop.7]+0x4a>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:345
    if (digitCodes[digitNum] & (1 << segmentNum)) { // Check a single bit
 20a:	e1 2f       	mov	r30, r17
 20c:	f0 e0       	ldi	r31, 0x00	; 0
 20e:	88 81       	ld	r24, Y
 210:	90 e0       	ldi	r25, 0x00	; 0
 212:	01 2e       	mov	r0, r17
 214:	02 c0       	rjmp	.+4      	; 0x21a <SevSeg::digitOn(unsigned char) [clone .constprop.7]+0x32>
 216:	95 95       	asr	r25
 218:	87 95       	ror	r24
 21a:	0a 94       	dec	r0
 21c:	e2 f7       	brpl	.-8      	; 0x216 <SevSeg::digitOn(unsigned char) [clone .constprop.7]+0x2e>
 21e:	80 ff       	sbrs	r24, 0
 220:	06 c0       	rjmp	.+12     	; 0x22e <SevSeg::digitOn(unsigned char) [clone .constprop.7]+0x46>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:346
      digitalWrite(segmentPins[segmentNum], segmentOnVal);
 222:	e9 53       	subi	r30, 0x39	; 57
 224:	ff 4f       	sbci	r31, 0xFF	; 255
 226:	60 91 c9 00 	lds	r22, 0x00C9	; 0x8000c9 <sevseg+0x2>
 22a:	87 85       	ldd	r24, Z+15	; 0x0f
 22c:	6f df       	rcall	.-290    	; 0x10c <digitalWrite>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:344
/******************************************************************************/
// Turns a digit on, as well as all corresponding segment pins
// (according to digitCodes[])
void SevSeg::digitOn(uint8_t digitNum) {
  digitalWrite(digitPins[digitNum], digitOnVal);
  for (uint8_t segmentNum = 0 ; segmentNum < numSegments ; segmentNum++) {
 22e:	1f 5f       	subi	r17, 0xFF	; 255
 230:	e8 cf       	rjmp	.-48     	; 0x202 <SevSeg::digitOn(unsigned char) [clone .constprop.7]+0x1a>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:349
    if (digitCodes[digitNum] & (1 << segmentNum)) { // Check a single bit
      digitalWrite(segmentPins[segmentNum], segmentOnVal);
    }
  }
}
 232:	df 91       	pop	r29
 234:	cf 91       	pop	r28
 236:	1f 91       	pop	r17
 238:	08 95       	ret

0000023a <SevSeg::segmentOn(unsigned char) [clone .constprop.6]>:
segmentOn():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:319

// segmentOn
/******************************************************************************/
// Turns a segment on, as well as all corresponding digit pins
// (according to digitCodes[])
void SevSeg::segmentOn(uint8_t segmentNum) {
 23a:	0f 93       	push	r16
 23c:	1f 93       	push	r17
 23e:	cf 93       	push	r28
 240:	c8 2f       	mov	r28, r24
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:320
  digitalWrite(segmentPins[segmentNum], segmentOnVal);
 242:	e8 2f       	mov	r30, r24
 244:	f0 e0       	ldi	r31, 0x00	; 0
 246:	e9 53       	subi	r30, 0x39	; 57
 248:	ff 4f       	sbci	r31, 0xFF	; 255
 24a:	60 91 c9 00 	lds	r22, 0x00C9	; 0x8000c9 <sevseg+0x2>
 24e:	87 85       	ldd	r24, Z+15	; 0x0f
 250:	5d df       	rcall	.-326    	; 0x10c <digitalWrite>
 252:	01 e0       	ldi	r16, 0x01	; 1
 254:	10 e0       	ldi	r17, 0x00	; 0
 256:	02 c0       	rjmp	.+4      	; 0x25c <SevSeg::segmentOn(unsigned char) [clone .constprop.6]+0x22>
 258:	00 0f       	add	r16, r16
 25a:	11 1f       	adc	r17, r17
 25c:	ca 95       	dec	r28
 25e:	e2 f7       	brpl	.-8      	; 0x258 <SevSeg::segmentOn(unsigned char) [clone .constprop.6]+0x1e>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:321
  for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
 260:	c0 e0       	ldi	r28, 0x00	; 0
 262:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <sevseg+0x17>
 266:	c8 17       	cp	r28, r24
 268:	80 f4       	brcc	.+32     	; 0x28a <SevSeg::segmentOn(unsigned char) [clone .constprop.6]+0x50>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:322
    if (digitCodes[digitNum] & (1 << segmentNum)) { // Check a single bit
 26a:	ec 2f       	mov	r30, r28
 26c:	f0 e0       	ldi	r31, 0x00	; 0
 26e:	e9 53       	subi	r30, 0x39	; 57
 270:	ff 4f       	sbci	r31, 0xFF	; 255
 272:	82 8d       	ldd	r24, Z+26	; 0x1a
 274:	90 e0       	ldi	r25, 0x00	; 0
 276:	80 23       	and	r24, r16
 278:	91 23       	and	r25, r17
 27a:	89 2b       	or	r24, r25
 27c:	21 f0       	breq	.+8      	; 0x286 <SevSeg::segmentOn(unsigned char) [clone .constprop.6]+0x4c>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:323
      digitalWrite(digitPins[digitNum], digitOnVal);
 27e:	60 91 c7 00 	lds	r22, 0x00C7	; 0x8000c7 <sevseg>
 282:	87 81       	ldd	r24, Z+7	; 0x07
 284:	43 df       	rcall	.-378    	; 0x10c <digitalWrite>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:321
/******************************************************************************/
// Turns a segment on, as well as all corresponding digit pins
// (according to digitCodes[])
void SevSeg::segmentOn(uint8_t segmentNum) {
  digitalWrite(segmentPins[segmentNum], segmentOnVal);
  for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
 286:	cf 5f       	subi	r28, 0xFF	; 255
 288:	ec cf       	rjmp	.-40     	; 0x262 <SevSeg::segmentOn(unsigned char) [clone .constprop.6]+0x28>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:326
    if (digitCodes[digitNum] & (1 << segmentNum)) { // Check a single bit
      digitalWrite(digitPins[digitNum], digitOnVal);
    }
  }
}
 28a:	cf 91       	pop	r28
 28c:	1f 91       	pop	r17
 28e:	0f 91       	pop	r16
 290:	08 95       	ret

00000292 <delayMicroseconds>:
delayMicroseconds():
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:827
  // we burned 15 (17) cycles above, plus 2 below, remove 3 (3 * 6 = 18)
  // us is at least 4 so we can subtract 3
  us -= 3; // = 2 cycles

#elif F_CPU >= 4000000L
  __asm__ __volatile__ ("nop"); // just waiting 1 cycle
 292:	00 00       	nop
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:829
  // the overhead of the function call is 15 (17) cycles which is 4 us
  if (us <= 4) return; // = 3 cycles, (4 when true)
 294:	85 30       	cpi	r24, 0x05	; 5
 296:	91 05       	cpc	r25, r1
 298:	18 f0       	brcs	.+6      	; 0x2a0 <delayMicroseconds+0xe>
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:832

  // subtract microseconds that were wasted in this function
  us -= 4; // = 2 cycles
 29a:	04 97       	sbiw	r24, 0x04	; 4
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:929
  us >>= 2; // us div 4, = 4 cycles

#endif

  // busy wait
  __asm__ __volatile__ (
 29c:	01 97       	sbiw	r24, 0x01	; 1
 29e:	f1 f7       	brne	.-4      	; 0x29c <delayMicroseconds+0xa>
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:939
    "   brne 1b"                     // 2 cycles
    : /* no outputs */
    : "w" (us)
  );
  // return = 4 cycles
}
 2a0:	08 95       	ret

000002a2 <__vector_9>:
__vector_9():
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:159
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 2a2:	1f 92       	push	r1
 2a4:	0f 92       	push	r0
 2a6:	0f b6       	in	r0, 0x3f	; 63
 2a8:	0f 92       	push	r0
 2aa:	11 24       	eor	r1, r1
 2ac:	2f 93       	push	r18
 2ae:	3f 93       	push	r19
 2b0:	8f 93       	push	r24
 2b2:	9f 93       	push	r25
 2b4:	af 93       	push	r26
 2b6:	bf 93       	push	r27
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:167
  static unsigned char timer0_exact = 0;
#endif

  // copy these to local variables so they can be stored in registers
  // (volatile variables must be read from memory on every access, so this saves time)
  unsigned long m = timer0_millis;
 2b8:	80 91 c3 00 	lds	r24, 0x00C3	; 0x8000c3 <timer0_millis>
 2bc:	90 91 c4 00 	lds	r25, 0x00C4	; 0x8000c4 <timer0_millis+0x1>
 2c0:	a0 91 c5 00 	lds	r26, 0x00C5	; 0x8000c5 <timer0_millis+0x2>
 2c4:	b0 91 c6 00 	lds	r27, 0x00C6	; 0x8000c6 <timer0_millis+0x3>
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:168
  unsigned char f = timer0_fract;
 2c8:	30 91 c2 00 	lds	r19, 0x00C2	; 0x8000c2 <timer0_fract>
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:170

  f += FRACT_INC FRACT_INC_PLUS;
 2cc:	2c e0       	ldi	r18, 0x0C	; 12
 2ce:	23 0f       	add	r18, r19
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:200
    ++f;
  }
#endif
#endif // CORRECT_EXACT_MILLIS

  if (f >= FRACT_MAX) {
 2d0:	2d 37       	cpi	r18, 0x7D	; 125
 2d2:	68 f1       	brcs	.+90     	; 0x32e <__vector_9+0x8c>
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:201
    f -= FRACT_MAX;
 2d4:	2f e8       	ldi	r18, 0x8F	; 143
 2d6:	23 0f       	add	r18, r19
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:202
    m += MILLIS_INC + 1;
 2d8:	05 96       	adiw	r24, 0x05	; 5
 2da:	a1 1d       	adc	r26, r1
 2dc:	b1 1d       	adc	r27, r1
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:208
  }
  else {
    m += MILLIS_INC;
  }

  timer0_fract = f;
 2de:	20 93 c2 00 	sts	0x00C2, r18	; 0x8000c2 <timer0_fract>
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:209
  timer0_millis = m;
 2e2:	80 93 c3 00 	sts	0x00C3, r24	; 0x8000c3 <timer0_millis>
 2e6:	90 93 c4 00 	sts	0x00C4, r25	; 0x8000c4 <timer0_millis+0x1>
 2ea:	a0 93 c5 00 	sts	0x00C5, r26	; 0x8000c5 <timer0_millis+0x2>
 2ee:	b0 93 c6 00 	sts	0x00C6, r27	; 0x8000c6 <timer0_millis+0x3>
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:211
#ifndef CORRECT_EXACT_MICROS
  timer0_overflow_count++;
 2f2:	80 91 be 00 	lds	r24, 0x00BE	; 0x8000be <__data_end>
 2f6:	90 91 bf 00 	lds	r25, 0x00BF	; 0x8000bf <__data_end+0x1>
 2fa:	a0 91 c0 00 	lds	r26, 0x00C0	; 0x8000c0 <__data_end+0x2>
 2fe:	b0 91 c1 00 	lds	r27, 0x00C1	; 0x8000c1 <__data_end+0x3>
 302:	01 96       	adiw	r24, 0x01	; 1
 304:	a1 1d       	adc	r26, r1
 306:	b1 1d       	adc	r27, r1
 308:	80 93 be 00 	sts	0x00BE, r24	; 0x8000be <__data_end>
 30c:	90 93 bf 00 	sts	0x00BF, r25	; 0x8000bf <__data_end+0x1>
 310:	a0 93 c0 00 	sts	0x00C0, r26	; 0x8000c0 <__data_end+0x2>
 314:	b0 93 c1 00 	sts	0x00C1, r27	; 0x8000c1 <__data_end+0x3>
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:213
#endif
}
 318:	bf 91       	pop	r27
 31a:	af 91       	pop	r26
 31c:	9f 91       	pop	r25
 31e:	8f 91       	pop	r24
 320:	3f 91       	pop	r19
 322:	2f 91       	pop	r18
 324:	0f 90       	pop	r0
 326:	0f be       	out	0x3f, r0	; 63
 328:	0f 90       	pop	r0
 32a:	1f 90       	pop	r1
 32c:	18 95       	reti
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:205
  if (f >= FRACT_MAX) {
    f -= FRACT_MAX;
    m += MILLIS_INC + 1;
  }
  else {
    m += MILLIS_INC;
 32e:	04 96       	adiw	r24, 0x04	; 4
 330:	a1 1d       	adc	r26, r1
 332:	b1 1d       	adc	r27, r1
 334:	d4 cf       	rjmp	.-88     	; 0x2de <__vector_9+0x3c>

00000336 <main>:
main():
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/main.cpp:34

//void setupUSB() __attribute__((weak));
//void setupUSB() { }

int main(void)
{
 336:	cf 93       	push	r28
 338:	df 93       	push	r29
 33a:	cd b7       	in	r28, 0x3d	; 61
 33c:	de b7       	in	r29, 0x3e	; 62
 33e:	61 97       	sbiw	r28, 0x11	; 17
 340:	0f b6       	in	r0, 0x3f	; 63
 342:	f8 94       	cli
 344:	de bf       	out	0x3e, r29	; 62
 346:	0f be       	out	0x3f, r0	; 63
 348:	cd bf       	out	0x3d, r28	; 61
init():
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:945

void init()
{
  // this needs to be called before setup() or some functions won't
  // work there
  sei();
 34a:	78 94       	sei
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:966
#if defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__)
  // CPU specific: different values for the ATmega64/128
  TCCR0 |= _BV(WGM01) | _BV(WGM00) | _BV(CS02);
#elif defined(TCCR0) && defined(CS01) && defined(CS00)
  // This combination is for the ATmega8535, ATmega8, ATmega16, ATmega32, ATmega8515, ATmega162
  TCCR0 |= _BV(CS01) | _BV(CS00);
 34c:	83 b7       	in	r24, 0x33	; 51
 34e:	83 60       	ori	r24, 0x03	; 3
 350:	83 bf       	out	0x33, r24	; 51
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:982
  #error Timer 0 prescale factor 64 not set correctly
#endif

// Enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
  TIMSK |= _BV(TOIE0);
 352:	89 b7       	in	r24, 0x39	; 57
 354:	81 60       	ori	r24, 0x01	; 1
 356:	89 bf       	out	0x39, r24	; 57
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:995
// this is better for motors as it ensures an even waveform
// note, however, that fast pwm mode can achieve a frequency of up
// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
  TCCR1B = _BV(CS11); // Set timer 1 prescale factor to 64
 358:	82 e0       	ldi	r24, 0x02	; 2
 35a:	8e bd       	out	0x2e, r24	; 46
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:1006
#if F_CPU >= 8000000L
  TCCR1 |= _BV(CS10);
#endif
#endif
#if defined(TCCR1A) && defined(WGM10)
  TCCR1A |= _BV(WGM10); // Put timer 1 in 8-bit phase correct pwm mode
 35c:	8f b5       	in	r24, 0x2f	; 47
 35e:	81 60       	ori	r24, 0x01	; 1
 360:	8f bd       	out	0x2f, r24	; 47
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:1011
#endif

// Set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
  TCCR2 |= _BV(CS22);
 362:	85 b5       	in	r24, 0x25	; 37
 364:	84 60       	ori	r24, 0x04	; 4
 366:	85 bd       	out	0x25, r24	; 37
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:1020
  TCCR2A |= _BV(CS22);
#endif

// Configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
  TCCR2 |= _BV(WGM20);
 368:	85 b5       	in	r24, 0x25	; 37
 36a:	80 64       	ori	r24, 0x40	; 64
 36c:	85 bd       	out	0x25, r24	; 37
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:1054
  #if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
    ADCSRA = _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0) | _BV(ADEN);
  #elif F_CPU >= 8000000 // 8 MHz / 64 = 125 KHz
    ADCSRA = _BV(ADPS2) | _BV(ADPS1) | _BV(ADEN);
  #elif F_CPU >= 4000000 // 4 MHz / 32 = 125 KHz
    ADCSRA = _BV(ADPS2) | _BV(ADPS0) | _BV(ADEN);
 36e:	85 e8       	ldi	r24, 0x85	; 133
 370:	86 b9       	out	0x06, r24	; 6
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:1068

  // The bootloader connects pins 0 and 1 to the USART; disconnect them
  // here so they can be used as normal digital i/o; they will be
  // reconnected in Serial.begin()
#if defined(UCSRB)
  UCSRB = 0;
 372:	1a b8       	out	0x0a, r1	; 10
setup():
/home/ferdous/electronics_works/git_project_files/Project_timer/seven_segment_test/seven_segment_test_atmega8.ino/seven_segment_test_atmega8.ino.ino:7
SevSeg sevseg; //Initiate a seven segment controller object


void setup() {
  byte numDigits = 4;
  byte digitPins[] = {5, 6, 7, 8};
 374:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 378:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 37c:	a0 91 62 00 	lds	r26, 0x0062	; 0x800062 <__DATA_REGION_ORIGIN__+0x2>
 380:	b0 91 63 00 	lds	r27, 0x0063	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
 384:	89 87       	std	Y+9, r24	; 0x09
 386:	9a 87       	std	Y+10, r25	; 0x0a
 388:	ab 87       	std	Y+11, r26	; 0x0b
 38a:	bc 87       	std	Y+12, r27	; 0x0c
/home/ferdous/electronics_works/git_project_files/Project_timer/seven_segment_test/seven_segment_test_atmega8.ino/seven_segment_test_atmega8.ino.ino:8
  byte segmentPins[] = {9, 10, 11, 12, 13, 14, 15, 16};
 38c:	88 e0       	ldi	r24, 0x08	; 8
 38e:	e4 e6       	ldi	r30, 0x64	; 100
 390:	f0 e0       	ldi	r31, 0x00	; 0
 392:	8e 01       	movw	r16, r28
 394:	0f 5f       	subi	r16, 0xFF	; 255
 396:	1f 4f       	sbci	r17, 0xFF	; 255
 398:	d8 01       	movw	r26, r16
 39a:	01 90       	ld	r0, Z+
 39c:	0d 92       	st	X+, r0
 39e:	8a 95       	dec	r24
 3a0:	e1 f7       	brne	.-8      	; 0x39a <main+0x64>
begin():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:124
// which case there are only 7 segments.
void SevSeg::begin(uint8_t hardwareConfig, uint8_t numDigitsIn, const uint8_t digitPinsIn[],
                   const uint8_t segmentPinsIn[], bool resOnSegmentsIn,
                   bool updateWithDelaysIn, bool leadingZerosIn, bool disableDecPoint) {

  resOnSegments = resOnSegmentsIn;
 3a2:	10 92 cb 00 	sts	0x00CB, r1	; 0x8000cb <sevseg+0x4>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:125
  updateWithDelays = updateWithDelaysIn;
 3a6:	10 92 cc 00 	sts	0x00CC, r1	; 0x8000cc <sevseg+0x5>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:126
  leadingZeros = leadingZerosIn;
 3aa:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <sevseg+0x6>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:128

  numDigits = numDigitsIn;
 3ae:	84 e0       	ldi	r24, 0x04	; 4
 3b0:	80 93 de 00 	sts	0x00DE, r24	; 0x8000de <sevseg+0x17>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:129
  numSegments = disableDecPoint ? 7 : 8; // Ternary 'if' statement
 3b4:	88 e0       	ldi	r24, 0x08	; 8
 3b6:	80 93 df 00 	sts	0x00DF, r24	; 0x8000df <sevseg+0x18>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:136
  if (numDigits > MAXNUMDIGITS) numDigits = MAXNUMDIGITS;

  switch (hardwareConfig) {

    case 0: // Common cathode
      digitOnVal = LOW;
 3ba:	10 92 c7 00 	sts	0x00C7, r1	; 0x8000c7 <sevseg>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:137
      segmentOnVal = HIGH;
 3be:	81 e0       	ldi	r24, 0x01	; 1
 3c0:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <sevseg+0x2>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:160

  // define the Off-Values depending on the On-Values
  if (digitOnVal == HIGH){
    digitOffVal = LOW;
  } else {
    digitOffVal = HIGH;
 3c4:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <sevseg+0x1>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:164
  }
  // define the Off-Values depending on the On-Values
  if (segmentOnVal == HIGH){
    segmentOffVal = LOW;
 3c8:	10 92 ca 00 	sts	0x00CA, r1	; 0x8000ca <sevseg+0x3>
 3cc:	f8 01       	movw	r30, r16
 3ce:	a6 ed       	ldi	r26, 0xD6	; 214
 3d0:	b0 e0       	ldi	r27, 0x00	; 0
 3d2:	ce 01       	movw	r24, r28
 3d4:	09 96       	adiw	r24, 0x09	; 9
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:171
    segmentOffVal = HIGH;
  }

  // Save the input pin numbers to library variables
  for (uint8_t segmentNum = 0 ; segmentNum < numSegments ; segmentNum++) {
    segmentPins[segmentNum] = segmentPinsIn[segmentNum];
 3d6:	21 91       	ld	r18, Z+
 3d8:	2d 93       	st	X+, r18
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:170
  } else {
    segmentOffVal = HIGH;
  }

  // Save the input pin numbers to library variables
  for (uint8_t segmentNum = 0 ; segmentNum < numSegments ; segmentNum++) {
 3da:	e8 17       	cp	r30, r24
 3dc:	f9 07       	cpc	r31, r25
 3de:	d9 f7       	brne	.-10     	; 0x3d6 <main+0xa0>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:175
    segmentPins[segmentNum] = segmentPinsIn[segmentNum];
  }

  for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
    digitPins[digitNum] = digitPinsIn[digitNum];
 3e0:	89 85       	ldd	r24, Y+9	; 0x09
 3e2:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <sevseg+0x7>
 3e6:	8a 85       	ldd	r24, Y+10	; 0x0a
 3e8:	80 93 cf 00 	sts	0x00CF, r24	; 0x8000cf <sevseg+0x8>
 3ec:	8b 85       	ldd	r24, Y+11	; 0x0b
 3ee:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <sevseg+0x9>
 3f2:	8c 85       	ldd	r24, Y+12	; 0x0c
 3f4:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <sevseg+0xa>
main():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:179
  }

  // Set the pins as outputs, and turn them off
  for (uint8_t digit = 0 ; digit < numDigits ; digit++) {
 3f8:	f1 2c       	mov	r15, r1
begin():
 3fa:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <sevseg+0x17>
 3fe:	f8 16       	cp	r15, r24
 400:	80 f4       	brcc	.+32     	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:180
    pinMode(digitPins[digit], OUTPUT);
 402:	8f 2d       	mov	r24, r15
 404:	90 e0       	ldi	r25, 0x00	; 0
 406:	9c 01       	movw	r18, r24
 408:	29 53       	subi	r18, 0x39	; 57
 40a:	3f 4f       	sbci	r19, 0xFF	; 255
 40c:	69 01       	movw	r12, r18
 40e:	f9 01       	movw	r30, r18
 410:	87 81       	ldd	r24, Z+7	; 0x07
 412:	5d de       	rcall	.-838    	; 0xce <pinMode.constprop.9>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:181
    digitalWrite(digitPins[digit], digitOffVal);
 414:	60 91 c8 00 	lds	r22, 0x00C8	; 0x8000c8 <sevseg+0x1>
 418:	f6 01       	movw	r30, r12
 41a:	87 81       	ldd	r24, Z+7	; 0x07
 41c:	77 de       	rcall	.-786    	; 0x10c <digitalWrite>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:179
  for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
    digitPins[digitNum] = digitPinsIn[digitNum];
  }

  // Set the pins as outputs, and turn them off
  for (uint8_t digit = 0 ; digit < numDigits ; digit++) {
 41e:	f3 94       	inc	r15
 420:	ec cf       	rjmp	.-40     	; 0x3fa <main+0xc4>
main():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:184
    pinMode(digitPins[digit], OUTPUT);
    digitalWrite(digitPins[digit], digitOffVal);
  }

  for (uint8_t segmentNum = 0 ; segmentNum < numSegments ; segmentNum++) {
 422:	f1 2c       	mov	r15, r1
begin():
 424:	80 91 df 00 	lds	r24, 0x00DF	; 0x8000df <sevseg+0x18>
 428:	f8 16       	cp	r15, r24
 42a:	50 f0       	brcs	.+20     	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
blank():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:511
}

// blank
/******************************************************************************/
void SevSeg::blank(void) {
  for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
 42c:	90 91 de 00 	lds	r25, 0x00DE	; 0x8000de <sevseg+0x17>
 430:	e1 ee       	ldi	r30, 0xE1	; 225
 432:	f0 e0       	ldi	r31, 0x00	; 0
main():
 434:	80 e0       	ldi	r24, 0x00	; 0
blank():
 436:	98 17       	cp	r25, r24
 438:	99 f0       	breq	.+38     	; 0x460 <__stack+0x1>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:512
    digitCodes[digitNum] = digitCodeMap[BLANK_IDX];
 43a:	11 92       	st	Z+, r1
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:511
}

// blank
/******************************************************************************/
void SevSeg::blank(void) {
  for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
 43c:	8f 5f       	subi	r24, 0xFF	; 255
 43e:	fb cf       	rjmp	.-10     	; 0x436 <__LOCK_REGION_LENGTH__+0x36>
begin():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:185
    pinMode(digitPins[digit], OUTPUT);
    digitalWrite(digitPins[digit], digitOffVal);
  }

  for (uint8_t segmentNum = 0 ; segmentNum < numSegments ; segmentNum++) {
    pinMode(segmentPins[segmentNum], OUTPUT);
 440:	8f 2d       	mov	r24, r15
 442:	90 e0       	ldi	r25, 0x00	; 0
 444:	9c 01       	movw	r18, r24
 446:	29 53       	subi	r18, 0x39	; 57
 448:	3f 4f       	sbci	r19, 0xFF	; 255
 44a:	69 01       	movw	r12, r18
 44c:	f9 01       	movw	r30, r18
 44e:	87 85       	ldd	r24, Z+15	; 0x0f
 450:	3e de       	rcall	.-900    	; 0xce <pinMode.constprop.9>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:186
    digitalWrite(segmentPins[segmentNum], segmentOffVal);
 452:	60 91 ca 00 	lds	r22, 0x00CA	; 0x8000ca <sevseg+0x3>
 456:	f6 01       	movw	r30, r12
 458:	87 85       	ldd	r24, Z+15	; 0x0f
 45a:	58 de       	rcall	.-848    	; 0x10c <digitalWrite>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:184
  for (uint8_t digit = 0 ; digit < numDigits ; digit++) {
    pinMode(digitPins[digit], OUTPUT);
    digitalWrite(digitPins[digit], digitOffVal);
  }

  for (uint8_t segmentNum = 0 ; segmentNum < numSegments ; segmentNum++) {
 45c:	f3 94       	inc	r15
 45e:	e2 cf       	rjmp	.-60     	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
blank():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:514
/******************************************************************************/
void SevSeg::blank(void) {
  for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
    digitCodes[digitNum] = digitCodeMap[BLANK_IDX];
  }
  segmentOff(0);
 460:	80 e0       	ldi	r24, 0x00	; 0
 462:	a6 de       	rcall	.-692    	; 0x1b0 <SevSeg::segmentOff(unsigned char) [clone .constprop.11]>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:515
  digitOff(0);
 464:	80 e0       	ldi	r24, 0x00	; 0
 466:	88 de       	rcall	.-752    	; 0x178 <SevSeg::digitOff(unsigned char) [clone .constprop.12]>
setBrightness():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:370
// A positive brightness introduces a delay while the LEDs are on, and a
// negative brightness introduces a delay while the LEDs are off.
void SevSeg::setBrightness(int16_t brightness) {
  brightness = constrain(brightness, -200, 200);
  if (brightness > 0) {
    ledOnTime = map(brightness, 0, 100, 1, 2000);
 468:	88 e0       	ldi	r24, 0x08	; 8
 46a:	97 e0       	ldi	r25, 0x07	; 7
 46c:	90 93 ee 00 	sts	0x00EE, r25	; 0x8000ee <sevseg+0x27>
 470:	80 93 ed 00 	sts	0x00ED, r24	; 0x8000ed <sevseg+0x26>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:371
    waitOffTime = 0;
 474:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <sevseg+0x29>
 478:	10 92 ef 00 	sts	0x00EF, r1	; 0x8000ef <sevseg+0x28>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:372
    waitOffActive = false;
 47c:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <sevseg+0x2a>
findDigits():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:525
// Decides what each digit will display.
// Enforces the upper and lower limits on the number to be displayed.
// digits[] is an output
void SevSeg::findDigits(int32_t numToShow, int8_t decPlaces, bool hex, uint8_t digits[]) {
  const int32_t * powersOfBase = hex ? powersOf16 : powersOf10;
  const int32_t maxNum = powersOfBase[numDigits] - 1;
 480:	f0 91 de 00 	lds	r31, 0x00DE	; 0x8000de <sevseg+0x17>
 484:	fd 87       	std	Y+13, r31	; 0x0d
 486:	cf 2e       	mov	r12, r31
 488:	d1 2c       	mov	r13, r1
 48a:	16 01       	movw	r2, r12
 48c:	22 0c       	add	r2, r2
 48e:	33 1c       	adc	r3, r3
 490:	22 0c       	add	r2, r2
 492:	33 1c       	adc	r3, r3
 494:	f1 01       	movw	r30, r2
 496:	eb 56       	subi	r30, 0x6B	; 107
 498:	ff 4f       	sbci	r31, 0xFF	; 255
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:529
  const int32_t minNum = -(powersOfBase[numDigits - 1] - 1);

  // If the number is out of range, just display dashes
  if (numToShow > maxNum || numToShow < minNum) {
 49a:	80 81       	ld	r24, Z
 49c:	91 81       	ldd	r25, Z+1	; 0x01
 49e:	a2 81       	ldd	r26, Z+2	; 0x02
 4a0:	b3 81       	ldd	r27, Z+3	; 0x03
 4a2:	83 3d       	cpi	r24, 0xD3	; 211
 4a4:	94 40       	sbci	r25, 0x04	; 4
 4a6:	a1 05       	cpc	r26, r1
 4a8:	b1 05       	cpc	r27, r1
 4aa:	2c f5       	brge	.+74     	; 0x4f6 <__stack+0x97>
main():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:511
}

// blank
/******************************************************************************/
void SevSeg::blank(void) {
  for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
 4ac:	f8 01       	movw	r30, r16
findDigits():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:530
  const int32_t maxNum = powersOfBase[numDigits] - 1;
  const int32_t minNum = -(powersOfBase[numDigits - 1] - 1);

  // If the number is out of range, just display dashes
  if (numToShow > maxNum || numToShow < minNum) {
    for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
 4ae:	8e 2f       	mov	r24, r30
 4b0:	80 1b       	sub	r24, r16
 4b2:	3d 85       	ldd	r19, Y+13	; 0x0d
 4b4:	83 17       	cp	r24, r19
 4b6:	08 f4       	brcc	.+2      	; 0x4ba <__stack+0x5b>
 4b8:	6d c0       	rjmp	.+218    	; 0x594 <__stack+0x135>
setDigitCodes():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:580
  // Set the digitCode for each digit in the display
  for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
    digitCodes[digitNum] = digitCodeMap[digits[digitNum]];
    // Set the decimal point segment
    if (decPlaces >= 0) {
      if (digitNum == numDigits - 1 - decPlaces) {
 4ba:	43 e0       	ldi	r20, 0x03	; 3
 4bc:	c4 1a       	sub	r12, r20
 4be:	d1 08       	sbc	r13, r1
 4c0:	a7 ec       	ldi	r26, 0xC7	; 199
 4c2:	b0 e0       	ldi	r27, 0x00	; 0
 4c4:	98 01       	movw	r18, r16
 4c6:	90 e0       	ldi	r25, 0x00	; 0
 4c8:	80 e0       	ldi	r24, 0x00	; 0
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:576
/******************************************************************************/
// Sets the 'digitCodes' that are required to display the input numbers
void SevSeg::setDigitCodes(const uint8_t digits[], int8_t decPlaces) {

  // Set the digitCode for each digit in the display
  for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
 4ca:	5d 85       	ldd	r21, Y+13	; 0x0d
 4cc:	85 17       	cp	r24, r21
 4ce:	08 f0       	brcs	.+2      	; 0x4d2 <__stack+0x73>
 4d0:	7f c0       	rjmp	.+254    	; 0x5d0 <__stack+0x171>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:577
    digitCodes[digitNum] = digitCodeMap[digits[digitNum]];
 4d2:	f9 01       	movw	r30, r18
 4d4:	41 91       	ld	r20, Z+
 4d6:	9f 01       	movw	r18, r30
 4d8:	e4 2f       	mov	r30, r20
 4da:	f0 e0       	ldi	r31, 0x00	; 0
 4dc:	e4 59       	subi	r30, 0x94	; 148
 4de:	ff 4f       	sbci	r31, 0xFF	; 255
 4e0:	40 81       	ld	r20, Z
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:580
    // Set the decimal point segment
    if (decPlaces >= 0) {
      if (digitNum == numDigits - 1 - decPlaces) {
 4e2:	8c 15       	cp	r24, r12
 4e4:	9d 05       	cpc	r25, r13
 4e6:	09 f4       	brne	.+2      	; 0x4ea <__stack+0x8b>
 4e8:	71 c0       	rjmp	.+226    	; 0x5cc <__stack+0x16d>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:581
        digitCodes[digitNum] |= digitCodeMap[PERIOD_IDX];
 4ea:	5a 96       	adiw	r26, 0x1a	; 26
 4ec:	4c 93       	st	X, r20
 4ee:	5a 97       	sbiw	r26, 0x1a	; 26
 4f0:	01 96       	adiw	r24, 0x01	; 1
 4f2:	11 96       	adiw	r26, 0x01	; 1
 4f4:	ea cf       	rjmp	.-44     	; 0x4ca <__stack+0x6b>
findDigits():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:526
// Enforces the upper and lower limits on the number to be displayed.
// digits[] is an output
void SevSeg::findDigits(int32_t numToShow, int8_t decPlaces, bool hex, uint8_t digits[]) {
  const int32_t * powersOfBase = hex ? powersOf16 : powersOf10;
  const int32_t maxNum = powersOfBase[numDigits] - 1;
  const int32_t minNum = -(powersOfBase[numDigits - 1] - 1);
 4f6:	d1 01       	movw	r26, r2
 4f8:	af 56       	subi	r26, 0x6F	; 111
 4fa:	bf 4f       	sbci	r27, 0xFF	; 255
 4fc:	8d 91       	ld	r24, X+
 4fe:	9d 91       	ld	r25, X+
 500:	0d 90       	ld	r0, X+
 502:	bc 91       	ld	r27, X
 504:	a0 2d       	mov	r26, r0
 506:	21 e0       	ldi	r18, 0x01	; 1
 508:	30 e0       	ldi	r19, 0x00	; 0
 50a:	40 e0       	ldi	r20, 0x00	; 0
 50c:	50 e0       	ldi	r21, 0x00	; 0
 50e:	28 1b       	sub	r18, r24
 510:	39 0b       	sbc	r19, r25
 512:	4a 0b       	sbc	r20, r26
 514:	5b 0b       	sbc	r21, r27
 516:	da 01       	movw	r26, r20
 518:	c9 01       	movw	r24, r18
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:529

  // If the number is out of range, just display dashes
  if (numToShow > maxNum || numToShow < minNum) {
 51a:	83 3d       	cpi	r24, 0xD3	; 211
 51c:	94 40       	sbci	r25, 0x04	; 4
 51e:	a1 05       	cpc	r26, r1
 520:	b1 05       	cpc	r27, r1
 522:	24 f6       	brge	.-120    	; 0x4ac <__stack+0x4d>
 524:	7f 01       	movw	r14, r30
 526:	1f 87       	std	Y+15, r17	; 0x0f
 528:	0e 87       	std	Y+14, r16	; 0x0e
 52a:	2c ef       	ldi	r18, 0xFC	; 252
 52c:	a6 01       	movw	r20, r12
 52e:	24 03       	mulsu	r18, r20
 530:	c0 01       	movw	r24, r0
 532:	25 9f       	mul	r18, r21
 534:	90 0d       	add	r25, r0
 536:	11 24       	eor	r1, r1
 538:	99 8b       	std	Y+17, r25	; 0x11
 53a:	88 8b       	std	Y+16, r24	; 0x10
 53c:	52 ed       	ldi	r21, 0xD2	; 210
 53e:	45 2e       	mov	r4, r21
 540:	54 e0       	ldi	r21, 0x04	; 4
 542:	55 2e       	mov	r5, r21
 544:	61 2c       	mov	r6, r1
 546:	71 2c       	mov	r7, r1
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:546
      numToShow = -numToShow;
    }

    // Find all digits for base's representation, starting with the most
    // significant digit
    for ( ; digitNum < numDigits ; digitNum++) {
 548:	85 e9       	ldi	r24, 0x95	; 149
 54a:	e8 16       	cp	r14, r24
 54c:	80 e0       	ldi	r24, 0x00	; 0
 54e:	f8 06       	cpc	r15, r24
 550:	21 f1       	breq	.+72     	; 0x59a <__stack+0x13b>
 552:	94 e0       	ldi	r25, 0x04	; 4
 554:	e9 1a       	sub	r14, r25
 556:	f1 08       	sbc	r15, r1
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:547
      int32_t factor = powersOfBase[numDigits - 1 - digitNum];
 558:	e8 89       	ldd	r30, Y+16	; 0x10
 55a:	f9 89       	ldd	r31, Y+17	; 0x11
 55c:	ee 0d       	add	r30, r14
 55e:	ff 1d       	adc	r31, r15
 560:	e2 0d       	add	r30, r2
 562:	f3 1d       	adc	r31, r3
 564:	80 80       	ld	r8, Z
 566:	91 80       	ldd	r9, Z+1	; 0x01
 568:	a2 80       	ldd	r10, Z+2	; 0x02
 56a:	b3 80       	ldd	r11, Z+3	; 0x03
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:548
      digits[digitNum] = numToShow / factor;
 56c:	c3 01       	movw	r24, r6
 56e:	b2 01       	movw	r22, r4
 570:	a5 01       	movw	r20, r10
 572:	94 01       	movw	r18, r8
 574:	08 d1       	rcall	.+528    	; 0x786 <__divmodsi4>
 576:	ee 85       	ldd	r30, Y+14	; 0x0e
 578:	ff 85       	ldd	r31, Y+15	; 0x0f
 57a:	21 93       	st	Z+, r18
 57c:	ff 87       	std	Y+15, r31	; 0x0f
 57e:	ee 87       	std	Y+14, r30	; 0x0e
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:549
      numToShow -= digits[digitNum] * factor;
 580:	a2 2f       	mov	r26, r18
 582:	b0 e0       	ldi	r27, 0x00	; 0
 584:	a5 01       	movw	r20, r10
 586:	94 01       	movw	r18, r8
 588:	1a d1       	rcall	.+564    	; 0x7be <__muluhisi3>
 58a:	46 1a       	sub	r4, r22
 58c:	57 0a       	sbc	r5, r23
 58e:	68 0a       	sbc	r6, r24
 590:	79 0a       	sbc	r7, r25
 592:	da cf       	rjmp	.-76     	; 0x548 <__stack+0xe9>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:531
  const int32_t minNum = -(powersOfBase[numDigits - 1] - 1);

  // If the number is out of range, just display dashes
  if (numToShow > maxNum || numToShow < minNum) {
    for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
      digits[digitNum] = DASH_IDX;
 594:	55 e2       	ldi	r21, 0x25	; 37
 596:	51 93       	st	Z+, r21
 598:	8a cf       	rjmp	.-236    	; 0x4ae <__stack+0x4f>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:554
      numToShow -= digits[digitNum] * factor;
    }

    // Find unnnecessary leading zeros and set them to BLANK
    if (decPlaces < 0) decPlaces = 0;
    if (!leadingZeros) {
 59a:	80 91 cd 00 	lds	r24, 0x00CD	; 0x8000cd <sevseg+0x6>
 59e:	81 11       	cpse	r24, r1
 5a0:	8c cf       	rjmp	.-232    	; 0x4ba <__stack+0x5b>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:555
      for (digitNum = 0 ; digitNum < (numDigits - 1 - decPlaces) ; digitNum++) {
 5a2:	96 01       	movw	r18, r12
 5a4:	23 50       	subi	r18, 0x03	; 3
 5a6:	31 09       	sbc	r19, r1
 5a8:	e8 2f       	mov	r30, r24
 5aa:	f0 e0       	ldi	r31, 0x00	; 0
 5ac:	e2 17       	cp	r30, r18
 5ae:	f3 07       	cpc	r31, r19
 5b0:	0c f0       	brlt	.+2      	; 0x5b4 <__stack+0x155>
 5b2:	83 cf       	rjmp	.-250    	; 0x4ba <__stack+0x5b>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:556
        if (digits[digitNum] == 0) {
 5b4:	e0 0f       	add	r30, r16
 5b6:	f1 1f       	adc	r31, r17
 5b8:	90 81       	ld	r25, Z
 5ba:	91 11       	cpse	r25, r1
 5bc:	04 c0       	rjmp	.+8      	; 0x5c6 <__stack+0x167>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:557
          digits[digitNum] = BLANK_IDX;
 5be:	44 e2       	ldi	r20, 0x24	; 36
 5c0:	40 83       	st	Z, r20
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:555
    }

    // Find unnnecessary leading zeros and set them to BLANK
    if (decPlaces < 0) decPlaces = 0;
    if (!leadingZeros) {
      for (digitNum = 0 ; digitNum < (numDigits - 1 - decPlaces) ; digitNum++) {
 5c2:	8f 5f       	subi	r24, 0xFF	; 255
 5c4:	f1 cf       	rjmp	.-30     	; 0x5a8 <__stack+0x149>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:560
        if (digits[digitNum] == 0) {
          digits[digitNum] = BLANK_IDX;
        }
        // Exit once the first non-zero number is encountered
        else if (digits[digitNum] <= 9) {
 5c6:	9a 30       	cpi	r25, 0x0A	; 10
 5c8:	e0 f7       	brcc	.-8      	; 0x5c2 <__stack+0x163>
 5ca:	77 cf       	rjmp	.-274    	; 0x4ba <__stack+0x5b>
setDigitCodes():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:581
  for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
    digitCodes[digitNum] = digitCodeMap[digits[digitNum]];
    // Set the decimal point segment
    if (decPlaces >= 0) {
      if (digitNum == numDigits - 1 - decPlaces) {
        digitCodes[digitNum] |= digitCodeMap[PERIOD_IDX];
 5cc:	40 68       	ori	r20, 0x80	; 128
 5ce:	8d cf       	rjmp	.-230    	; 0x4ea <__stack+0x8b>
refreshDisplay():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:213
//    on. It will move to the next digit/segment after being called again (if
//    enough time has passed).

void SevSeg::refreshDisplay() {

  if (!updateWithDelays) {
 5d0:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <sevseg+0x5>
 5d4:	81 11       	cpse	r24, r1
 5d6:	93 c0       	rjmp	.+294    	; 0x6fe <__stack+0x29f>
micros():
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:237
  unsigned char f; // temporary storage for millis fraction counter
  unsigned char q = 0; // record whether an overflow is flagged
#endif
  // t will be the number where the timer0 counter stopped
  uint8_t t;
  uint8_t oldSREG = SREG;
 5d8:	3f b7       	in	r19, 0x3f	; 63
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:240

  // Stop all interrupts
  cli();
 5da:	f8 94       	cli
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:247
#ifdef CORRECT_EXACT_MICROS
  // combine exact millisec and 8usec counters
  m = timer0_millis;
  f = timer0_fract;
#else
  m = timer0_overflow_count;
 5dc:	80 91 be 00 	lds	r24, 0x00BE	; 0x8000be <__data_end>
 5e0:	90 91 bf 00 	lds	r25, 0x00BF	; 0x8000bf <__data_end+0x1>
 5e4:	a0 91 c0 00 	lds	r26, 0x00C0	; 0x8000c0 <__data_end+0x2>
 5e8:	b0 91 c1 00 	lds	r27, 0x00C1	; 0x8000c1 <__data_end+0x3>
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:252
#endif

  // TCNT0 : The Timer Counter Register
#if defined(TCNT0)
  t = TCNT0;
 5ec:	22 b7       	in	r18, 0x32	; 50
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:268
    m++;
#else
    q = 1;
#endif
#else
  if ((TIFR & _BV(TOV0)) && (t < 255))
 5ee:	08 b6       	in	r0, 0x38	; 56
 5f0:	00 fe       	sbrs	r0, 0
 5f2:	05 c0       	rjmp	.+10     	; 0x5fe <__stack+0x19f>
 5f4:	2f 3f       	cpi	r18, 0xFF	; 255
 5f6:	19 f0       	breq	.+6      	; 0x5fe <__stack+0x19f>
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:270
#ifndef CORRECT_EXACT_MICROS
    m++;
 5f8:	01 96       	adiw	r24, 0x01	; 1
 5fa:	a1 1d       	adc	r26, r1
 5fc:	b1 1d       	adc	r27, r1
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:276
#else
    q = 1;
#endif
#endif
  // Restore SREG
  SREG = oldSREG;
 5fe:	3f bf       	out	0x3f, r19	; 63
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/wiring.c:292
      ((t * MICROSECONDS_PER_TIMER0_OVERFLOW) >> 8);
  return q ? m + MICROSECONDS_PER_TIMER0_OVERFLOW : m;
#elif 1
  /* All power-of-two Megahertz frequencies enter here, as well as 12.8 MHz.
     We only end up here if right shift before multiplication is exact. */
  return ((m << 8) + t) * (MICROSECONDS_PER_TIMER0_OVERFLOW >> 8);
 600:	ba 2f       	mov	r27, r26
 602:	a9 2f       	mov	r26, r25
 604:	98 2f       	mov	r25, r24
 606:	88 27       	eor	r24, r24
 608:	82 0f       	add	r24, r18
 60a:	91 1d       	adc	r25, r1
 60c:	a1 1d       	adc	r26, r1
 60e:	b1 1d       	adc	r27, r1
 610:	44 e0       	ldi	r20, 0x04	; 4
 612:	88 0f       	add	r24, r24
 614:	99 1f       	adc	r25, r25
 616:	aa 1f       	adc	r26, r26
 618:	bb 1f       	adc	r27, r27
 61a:	4a 95       	dec	r20
 61c:	d1 f7       	brne	.-12     	; 0x612 <__stack+0x1b3>
refreshDisplay():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:217
    uint32_t us = micros();

    // Exit if it's not time for the next display change
    if (waitOffActive) {
 61e:	20 91 f1 00 	lds	r18, 0x00F1	; 0x8000f1 <sevseg+0x2a>
 622:	40 91 e9 00 	lds	r20, 0x00E9	; 0x8000e9 <sevseg+0x22>
 626:	50 91 ea 00 	lds	r21, 0x00EA	; 0x8000ea <sevseg+0x23>
 62a:	60 91 eb 00 	lds	r22, 0x00EB	; 0x8000eb <sevseg+0x24>
 62e:	70 91 ec 00 	lds	r23, 0x00EC	; 0x8000ec <sevseg+0x25>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:218
      if ((int32_t)(us - prevUpdateTime) < waitOffTime) return;
 632:	6c 01       	movw	r12, r24
 634:	7d 01       	movw	r14, r26
 636:	c4 1a       	sub	r12, r20
 638:	d5 0a       	sbc	r13, r21
 63a:	e6 0a       	sbc	r14, r22
 63c:	f7 0a       	sbc	r15, r23
 63e:	40 91 ef 00 	lds	r20, 0x00EF	; 0x8000ef <sevseg+0x28>
 642:	50 91 f0 00 	lds	r21, 0x00F0	; 0x8000f0 <sevseg+0x29>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:217

  if (!updateWithDelays) {
    uint32_t us = micros();

    // Exit if it's not time for the next display change
    if (waitOffActive) {
 646:	21 11       	cpse	r18, r1
 648:	04 c0       	rjmp	.+8      	; 0x652 <__stack+0x1f3>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:221
      if ((int32_t)(us - prevUpdateTime) < waitOffTime) return;
    }
    else {
      if ((int32_t)(us - prevUpdateTime) < ledOnTime) return;
 64a:	40 91 ed 00 	lds	r20, 0x00ED	; 0x8000ed <sevseg+0x26>
 64e:	50 91 ee 00 	lds	r21, 0x00EE	; 0x8000ee <sevseg+0x27>
 652:	05 2e       	mov	r0, r21
 654:	00 0c       	add	r0, r0
 656:	66 0b       	sbc	r22, r22
 658:	77 0b       	sbc	r23, r23
 65a:	c4 16       	cp	r12, r20
 65c:	d5 06       	cpc	r13, r21
 65e:	e6 06       	cpc	r14, r22
 660:	f7 06       	cpc	r15, r23
 662:	5c f1       	brlt	.+86     	; 0x6ba <__stack+0x25b>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:223
    }
    prevUpdateTime = us;
 664:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <sevseg+0x22>
 668:	90 93 ea 00 	sts	0x00EA, r25	; 0x8000ea <sevseg+0x23>
 66c:	a0 93 eb 00 	sts	0x00EB, r26	; 0x8000eb <sevseg+0x24>
 670:	b0 93 ec 00 	sts	0x00EC, r27	; 0x8000ec <sevseg+0x25>
 674:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <sevseg+0x19>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:225

    if (!resOnSegments) {
 678:	90 91 cb 00 	lds	r25, 0x00CB	; 0x8000cb <sevseg+0x4>
 67c:	91 11       	cpse	r25, r1
 67e:	24 c0       	rjmp	.+72     	; 0x6c8 <__stack+0x269>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:229
      /**********************************************/
      // RESISTORS ON DIGITS, UPDATE WITHOUT DELAYS

      if (waitOffActive) {
 680:	22 23       	and	r18, r18
 682:	89 f0       	breq	.+34     	; 0x6a6 <__stack+0x247>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:230
        waitOffActive = false;
 684:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <sevseg+0x2a>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:243
          waitOffActive = true;
          return;
        }
      }

      prevUpdateIdx++;
 688:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <sevseg+0x19>
 68c:	8f 5f       	subi	r24, 0xFF	; 255
 68e:	80 93 e0 00 	sts	0x00E0, r24	; 0x8000e0 <sevseg+0x19>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:244
      if (prevUpdateIdx >= numSegments) prevUpdateIdx = 0;
 692:	90 91 df 00 	lds	r25, 0x00DF	; 0x8000df <sevseg+0x18>
 696:	89 17       	cp	r24, r25
 698:	10 f0       	brcs	.+4      	; 0x69e <__stack+0x23f>
 69a:	10 92 e0 00 	sts	0x00E0, r1	; 0x8000e0 <sevseg+0x19>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:247

      // Illuminate the required digits for the new segment
      segmentOn(prevUpdateIdx);
 69e:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <sevseg+0x19>
 6a2:	cb dd       	rcall	.-1130   	; 0x23a <SevSeg::segmentOn(unsigned char) [clone .constprop.6]>
 6a4:	0a c0       	rjmp	.+20     	; 0x6ba <__stack+0x25b>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:234
      if (waitOffActive) {
        waitOffActive = false;
      }
      else {
        // Turn all lights off for the previous segment
        segmentOff(prevUpdateIdx);
 6a6:	84 dd       	rcall	.-1272   	; 0x1b0 <SevSeg::segmentOff(unsigned char) [clone .constprop.11]>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:236

        if (waitOffTime) {
 6a8:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <sevseg+0x28>
 6ac:	90 91 f0 00 	lds	r25, 0x00F0	; 0x8000f0 <sevseg+0x29>
 6b0:	89 2b       	or	r24, r25
 6b2:	51 f3       	breq	.-44     	; 0x688 <__stack+0x229>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:238
          // Wait a delay with all lights off
          waitOffActive = true;
 6b4:	f1 e0       	ldi	r31, 0x01	; 1
 6b6:	f0 93 f1 00 	sts	0x00F1, r31	; 0x8000f1 <sevseg+0x2a>
main():
/home/ferdous/.arduino15/packages/MiniCore/hardware/avr/3.0.3/cores/MCUdude_corefiles/main.cpp:47
  
  setup();
    
  for (;;) {
    loop();
    if (serialEventRun) serialEventRun();
 6ba:	20 e0       	ldi	r18, 0x00	; 0
 6bc:	30 e0       	ldi	r19, 0x00	; 0
 6be:	23 2b       	or	r18, r19
 6c0:	09 f4       	brne	.+2      	; 0x6c4 <__stack+0x265>
 6c2:	de ce       	rjmp	.-580    	; 0x480 <__stack+0x21>
 6c4:	9d dc       	rcall	.-1734   	; 0x0 <__vectors>
 6c6:	dc ce       	rjmp	.-584    	; 0x480 <__stack+0x21>
refreshDisplay():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:253
    }
    else {
      /**********************************************/
      // RESISTORS ON SEGMENTS, UPDATE WITHOUT DELAYS

      if (waitOffActive) {
 6c8:	22 23       	and	r18, r18
 6ca:	89 f0       	breq	.+34     	; 0x6ee <__stack+0x28f>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:254
        waitOffActive = false;
 6cc:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <sevseg+0x2a>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:267
          waitOffActive = true;
          return;
        }
      }

      prevUpdateIdx++;
 6d0:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <sevseg+0x19>
 6d4:	8f 5f       	subi	r24, 0xFF	; 255
 6d6:	80 93 e0 00 	sts	0x00E0, r24	; 0x8000e0 <sevseg+0x19>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:268
      if (prevUpdateIdx >= numDigits) prevUpdateIdx = 0;
 6da:	90 91 de 00 	lds	r25, 0x00DE	; 0x8000de <sevseg+0x17>
 6de:	89 17       	cp	r24, r25
 6e0:	10 f0       	brcs	.+4      	; 0x6e6 <__stack+0x287>
 6e2:	10 92 e0 00 	sts	0x00E0, r1	; 0x8000e0 <sevseg+0x19>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:271

      // Illuminate the required segments for the new digit
      digitOn(prevUpdateIdx);
 6e6:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <sevseg+0x19>
 6ea:	7e dd       	rcall	.-1284   	; 0x1e8 <SevSeg::digitOn(unsigned char) [clone .constprop.7]>
 6ec:	e6 cf       	rjmp	.-52     	; 0x6ba <__stack+0x25b>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:258
      if (waitOffActive) {
        waitOffActive = false;
      }
      else {
        // Turn all lights off for the previous digit
        digitOff(prevUpdateIdx);
 6ee:	44 dd       	rcall	.-1400   	; 0x178 <SevSeg::digitOff(unsigned char) [clone .constprop.12]>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:260

        if (waitOffTime) {
 6f0:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <sevseg+0x28>
 6f4:	90 91 f0 00 	lds	r25, 0x00F0	; 0x8000f0 <sevseg+0x29>
 6f8:	89 2b       	or	r24, r25
 6fa:	51 f3       	breq	.-44     	; 0x6d0 <__stack+0x271>
 6fc:	db cf       	rjmp	.-74     	; 0x6b4 <__stack+0x255>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:276
      digitOn(prevUpdateIdx);
    }
  }

  else {
    if (!resOnSegments) {
 6fe:	80 91 cb 00 	lds	r24, 0x00CB	; 0x8000cb <sevseg+0x4>
main():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:279
      /**********************************************/
      // RESISTORS ON DIGITS, UPDATE WITH DELAYS
      for (uint8_t segmentNum = 0 ; segmentNum < numSegments ; segmentNum++) {
 702:	f1 2c       	mov	r15, r1
refreshDisplay():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:276
      digitOn(prevUpdateIdx);
    }
  }

  else {
    if (!resOnSegments) {
 704:	81 11       	cpse	r24, r1
 706:	16 c0       	rjmp	.+44     	; 0x734 <__stack+0x2d5>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:279
      /**********************************************/
      // RESISTORS ON DIGITS, UPDATE WITH DELAYS
      for (uint8_t segmentNum = 0 ; segmentNum < numSegments ; segmentNum++) {
 708:	80 91 df 00 	lds	r24, 0x00DF	; 0x8000df <sevseg+0x18>
 70c:	f8 16       	cp	r15, r24
 70e:	a8 f6       	brcc	.-86     	; 0x6ba <__stack+0x25b>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:282

        // Illuminate the required digits for this segment
        segmentOn(segmentNum);
 710:	8f 2d       	mov	r24, r15
 712:	93 dd       	rcall	.-1242   	; 0x23a <SevSeg::segmentOn(unsigned char) [clone .constprop.6]>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:285

        // Wait with lights on (to increase brightness)
        delayMicroseconds(ledOnTime);
 714:	80 91 ed 00 	lds	r24, 0x00ED	; 0x8000ed <sevseg+0x26>
 718:	90 91 ee 00 	lds	r25, 0x00EE	; 0x8000ee <sevseg+0x27>
 71c:	ba dd       	rcall	.-1164   	; 0x292 <delayMicroseconds>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:288

        // Turn all lights off
        segmentOff(segmentNum);
 71e:	8f 2d       	mov	r24, r15
 720:	47 dd       	rcall	.-1394   	; 0x1b0 <SevSeg::segmentOff(unsigned char) [clone .constprop.11]>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:291

        // Wait with all lights off if required
        if (waitOffTime) delayMicroseconds(waitOffTime);
 722:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <sevseg+0x28>
 726:	90 91 f0 00 	lds	r25, 0x00F0	; 0x8000f0 <sevseg+0x29>
 72a:	00 97       	sbiw	r24, 0x00	; 0
 72c:	09 f0       	breq	.+2      	; 0x730 <__stack+0x2d1>
 72e:	b1 dd       	rcall	.-1182   	; 0x292 <delayMicroseconds>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:279

  else {
    if (!resOnSegments) {
      /**********************************************/
      // RESISTORS ON DIGITS, UPDATE WITH DELAYS
      for (uint8_t segmentNum = 0 ; segmentNum < numSegments ; segmentNum++) {
 730:	f3 94       	inc	r15
 732:	ea cf       	rjmp	.-44     	; 0x708 <__stack+0x2a9>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:297
      }
    }
    else {
      /**********************************************/
      // RESISTORS ON SEGMENTS, UPDATE WITH DELAYS
      for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
 734:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <sevseg+0x17>
 738:	f8 16       	cp	r15, r24
 73a:	08 f0       	brcs	.+2      	; 0x73e <__stack+0x2df>
 73c:	be cf       	rjmp	.-132    	; 0x6ba <__stack+0x25b>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:300

        // Illuminate the required segments for this digit
        digitOn(digitNum);
 73e:	8f 2d       	mov	r24, r15
 740:	53 dd       	rcall	.-1370   	; 0x1e8 <SevSeg::digitOn(unsigned char) [clone .constprop.7]>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:303

        // Wait with lights on (to increase brightness)
        delayMicroseconds(ledOnTime);
 742:	80 91 ed 00 	lds	r24, 0x00ED	; 0x8000ed <sevseg+0x26>
 746:	90 91 ee 00 	lds	r25, 0x00EE	; 0x8000ee <sevseg+0x27>
 74a:	a3 dd       	rcall	.-1210   	; 0x292 <delayMicroseconds>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:306

        // Turn all lights off
        digitOff(digitNum);
 74c:	8f 2d       	mov	r24, r15
 74e:	14 dd       	rcall	.-1496   	; 0x178 <SevSeg::digitOff(unsigned char) [clone .constprop.12]>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:309

        // Wait with all lights off if required
        if (waitOffTime) delayMicroseconds(waitOffTime);
 750:	80 91 ef 00 	lds	r24, 0x00EF	; 0x8000ef <sevseg+0x28>
 754:	90 91 f0 00 	lds	r25, 0x00F0	; 0x8000f0 <sevseg+0x29>
 758:	00 97       	sbiw	r24, 0x00	; 0
 75a:	09 f0       	breq	.+2      	; 0x75e <__stack+0x2ff>
 75c:	9a dd       	rcall	.-1228   	; 0x292 <delayMicroseconds>
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:297
      }
    }
    else {
      /**********************************************/
      // RESISTORS ON SEGMENTS, UPDATE WITH DELAYS
      for (uint8_t digitNum = 0 ; digitNum < numDigits ; digitNum++) {
 75e:	f3 94       	inc	r15
 760:	e9 cf       	rjmp	.-46     	; 0x734 <__stack+0x2d5>

00000762 <_GLOBAL__sub_I_sevseg>:
__base_ctor ():
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:99

// SevSeg Constructor
/******************************************************************************/
SevSeg::SevSeg() {
  // Initial value
  ledOnTime = 2000; // Corresponds to a brightness of 100
 762:	e7 ec       	ldi	r30, 0xC7	; 199
 764:	f0 e0       	ldi	r31, 0x00	; 0
 766:	80 ed       	ldi	r24, 0xD0	; 208
 768:	97 e0       	ldi	r25, 0x07	; 7
 76a:	97 a3       	std	Z+39, r25	; 0x27
 76c:	86 a3       	std	Z+38, r24	; 0x26
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:100
  waitOffTime = 0;
 76e:	11 a6       	std	Z+41, r1	; 0x29
 770:	10 a6       	std	Z+40, r1	; 0x28
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:101
  waitOffActive = false;
 772:	12 a6       	std	Z+42, r1	; 0x2a
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:102
  numDigits = 0;
 774:	17 8a       	std	Z+23, r1	; 0x17
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:103
  prevUpdateIdx = 0;
 776:	11 8e       	std	Z+25, r1	; 0x19
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:104
  prevUpdateTime = 0;
 778:	12 a2       	std	Z+34, r1	; 0x22
 77a:	13 a2       	std	Z+35, r1	; 0x23
 77c:	14 a2       	std	Z+36, r1	; 0x24
 77e:	15 a2       	std	Z+37, r1	; 0x25
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:105
  resOnSegments = 0;
 780:	14 82       	std	Z+4, r1	; 0x04
/home/ferdous/Arduino/libraries/SevSeg/SevSeg.cpp:106
  updateWithDelays = 0;
 782:	15 82       	std	Z+5, r1	; 0x05
_GLOBAL__sub_I_sevseg():
/home/ferdous/electronics_works/git_project_files/Project_timer/seven_segment_test/seven_segment_test_atmega8.ino/seven_segment_test_atmega8.ino.ino:18
  sevseg.setBrightness(90);
}
void loop() {
  sevseg.setNumber(1234, 2);
  sevseg.refreshDisplay(); // Must run repeatedly
 784:	08 95       	ret

00000786 <__divmodsi4>:
__divmodsi4():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1686
 786:	05 2e       	mov	r0, r21
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1687
 788:	97 fb       	bst	r25, 7
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1688
 78a:	16 f4       	brtc	.+4      	; 0x790 <__divmodsi4+0xa>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1689
 78c:	00 94       	com	r0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1690
 78e:	0f d0       	rcall	.+30     	; 0x7ae <__negsi2>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1692
 790:	57 fd       	sbrc	r21, 7
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1693
 792:	05 d0       	rcall	.+10     	; 0x79e <__divmodsi4_neg2>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1694
 794:	1e d0       	rcall	.+60     	; 0x7d2 <__udivmodsi4>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1695
 796:	07 fc       	sbrc	r0, 7
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1696
 798:	02 d0       	rcall	.+4      	; 0x79e <__divmodsi4_neg2>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1697
 79a:	46 f4       	brtc	.+16     	; 0x7ac <__divmodsi4_exit>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1698
 79c:	08 c0       	rjmp	.+16     	; 0x7ae <__negsi2>

0000079e <__divmodsi4_neg2>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1701
 79e:	50 95       	com	r21
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1702
 7a0:	40 95       	com	r20
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1703
 7a2:	30 95       	com	r19
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1704
 7a4:	21 95       	neg	r18
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1705
 7a6:	3f 4f       	sbci	r19, 0xFF	; 255
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1706
 7a8:	4f 4f       	sbci	r20, 0xFF	; 255
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1707
 7aa:	5f 4f       	sbci	r21, 0xFF	; 255

000007ac <__divmodsi4_exit>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1709
 7ac:	08 95       	ret

000007ae <__negsi2>:
__negsi2():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1718
 7ae:	90 95       	com	r25
 7b0:	80 95       	com	r24
 7b2:	70 95       	com	r23
 7b4:	61 95       	neg	r22
 7b6:	7f 4f       	sbci	r23, 0xFF	; 255
 7b8:	8f 4f       	sbci	r24, 0xFF	; 255
 7ba:	9f 4f       	sbci	r25, 0xFF	; 255
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1719
 7bc:	08 95       	ret

000007be <__muluhisi3>:
__muluhisi3():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
 7be:	2b d0       	rcall	.+86     	; 0x816 <__umulhisi3>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
 7c0:	a5 9f       	mul	r26, r21
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
 7c2:	90 0d       	add	r25, r0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
 7c4:	b4 9f       	mul	r27, r20
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
 7c6:	90 0d       	add	r25, r0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
 7c8:	a4 9f       	mul	r26, r20
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
 7ca:	80 0d       	add	r24, r0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
 7cc:	91 1d       	adc	r25, r1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
 7ce:	11 24       	eor	r1, r1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
 7d0:	08 95       	ret

000007d2 <__udivmodsi4>:
__udivmodsi4():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
 7d2:	a1 e2       	ldi	r26, 0x21	; 33
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
 7d4:	1a 2e       	mov	r1, r26
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
 7d6:	aa 1b       	sub	r26, r26
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
 7d8:	bb 1b       	sub	r27, r27
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
 7da:	fd 01       	movw	r30, r26
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
 7dc:	0d c0       	rjmp	.+26     	; 0x7f8 <__udivmodsi4_ep>

000007de <__udivmodsi4_loop>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
 7de:	aa 1f       	adc	r26, r26
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
 7e0:	bb 1f       	adc	r27, r27
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
 7e2:	ee 1f       	adc	r30, r30
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
 7e4:	ff 1f       	adc	r31, r31
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
 7e6:	a2 17       	cp	r26, r18
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
 7e8:	b3 07       	cpc	r27, r19
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
 7ea:	e4 07       	cpc	r30, r20
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
 7ec:	f5 07       	cpc	r31, r21
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
 7ee:	20 f0       	brcs	.+8      	; 0x7f8 <__udivmodsi4_ep>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
 7f0:	a2 1b       	sub	r26, r18
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
 7f2:	b3 0b       	sbc	r27, r19
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
 7f4:	e4 0b       	sbc	r30, r20
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
 7f6:	f5 0b       	sbc	r31, r21

000007f8 <__udivmodsi4_ep>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
 7f8:	66 1f       	adc	r22, r22
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
 7fa:	77 1f       	adc	r23, r23
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
 7fc:	88 1f       	adc	r24, r24
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
 7fe:	99 1f       	adc	r25, r25
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
 800:	1a 94       	dec	r1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
 802:	69 f7       	brne	.-38     	; 0x7de <__udivmodsi4_loop>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
 804:	60 95       	com	r22
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
 806:	70 95       	com	r23
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
 808:	80 95       	com	r24
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
 80a:	90 95       	com	r25
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
 80c:	9b 01       	movw	r18, r22
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
 80e:	ac 01       	movw	r20, r24
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
 810:	bd 01       	movw	r22, r26
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
 812:	cf 01       	movw	r24, r30
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
 814:	08 95       	ret

00000816 <__umulhisi3>:
__umulhisi3():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
 816:	a2 9f       	mul	r26, r18
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
 818:	b0 01       	movw	r22, r0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
 81a:	b3 9f       	mul	r27, r19
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
 81c:	c0 01       	movw	r24, r0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
 81e:	a3 9f       	mul	r26, r19
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:578
 820:	01 d0       	rcall	.+2      	; 0x824 <__umulhisi3+0xe>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
 822:	b2 9f       	mul	r27, r18
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
 824:	70 0d       	add	r23, r0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
 826:	81 1d       	adc	r24, r1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
 828:	11 24       	eor	r1, r1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
 82a:	91 1d       	adc	r25, r1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
 82c:	08 95       	ret

0000082e <__tablejump2__>:
__tablejump2__():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 82e:	ee 0f       	add	r30, r30
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 830:	ff 1f       	adc	r31, r31
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 832:	05 90       	lpm	r0, Z+
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 834:	f4 91       	lpm	r31, Z
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 836:	e0 2d       	mov	r30, r0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 838:	09 94       	ijmp

0000083a <_exit>:
exit():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 83a:	f8 94       	cli

0000083c <__stop_program>:
__stop_program():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 83c:	ff cf       	rjmp	.-2      	; 0x83c <__stop_program>
